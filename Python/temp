import os
import subprocess
import pyautogui
import time
import pyperclip  # 确保导入pyperclip库
import re


def remove_blank_lines(file_path, output_path=None):
    try:
        # 读取源文件内容
        with open(file_path, 'r', encoding='utf-8') as f:
            lines = f.readlines()

        # 删除空白行（包括仅包含空格或制表符的行）
        cleaned_lines = [line for line in lines if not re.match(r'^\s*$', line)]

        # 如果未指定 output_path，则覆盖原文件
        if output_path is None:
            output_path = file_path

        # 将清理后的内容写入目标文件
        with open(output_path, 'w', encoding='utf-8', newline='\r\n') as f:
            f.writelines(cleaned_lines)
    except FileNotFoundError:
        print(f"文件未找到: {file_path}")
    except Exception as e:
        print(f"发生错误: {e}")
def open_notepad_and_copy(file_path, copy_file_path):
    # 打开记事本并加载指定文件
    subprocess.Popen(['notepad.exe', file_path])
    time.sleep(1)  # 等待记事本打开文件，根据实际情况调整时间

    # 全选文本内容
    pyautogui.hotkey('ctrl', 'a')
    time.sleep(0.5)  # 短暂等待，确保全选操作完成

    # 复制文本内容到剪贴板
    pyautogui.hotkey('ctrl', 'c')
    time.sleep(0.5)  # 短暂等待，确保复制操作完成

    # 获取剪贴板中的内容
    content = pyperclip.paste()
    print(f"复制的文件内容:\n{content}")

    # 关闭记事本窗口
    pyautogui.hotkey('alt', 'f4')
    time.sleep(1)  # 短暂等待，确保窗口关闭
    lines = content.splitlines()
    # 使用正则表达式过滤掉仅包含空白字符的行
    cleaned_lines = [line for line in lines if not re.match(r'^\s*$', line)]

    # 统一换行符为 Windows 格式 (\r\n)
    cleaned_content = '\r\n'.join(cleaned_lines)
    # 将内容写入到目标文件
    with open(copy_file_path, 'w', encoding='utf-8') as f:
        f.write(cleaned_content)
    print(f"内容已保存到: {copy_file_path}")
    print(cleaned_content)
    remove_blank_lines(copy_file_path)

def traverse_directory(directory):

    file_list = []
    for root, dirs, files in os.walk(directory):
        for file in files:
            file_path = os.path.join(root, file)  # 构建完整文件路径
            file_list.append(file_path)
    return file_list
def main():
    # 获取当前脚本所在文件夹的路径
    folder_path = os.path.dirname(os.path.abspath(__file__))
    files=traverse_directory(folder_path)
    print(f"当前脚本所在文件夹: {folder_path}")

    # 创建Copying子文件夹
    copying_folder_path = os.path.join(folder_path, 'Copying')
    if not os.path.exists(copying_folder_path):
        os.makedirs(copying_folder_path)
        print(f"已创建文件夹: {copying_folder_path}")
    
    print(f"正在处理文件: {files}")
    # 遍历文件夹下所有文件
    for root, dirs, files in os.walk(folder_path):
        for file in files:
            print(f"正在处理文件: {file}")
            if file.endswith('.c') or file.endswith('.h') or file.endswith('.cpp'):
                print("=" * 50)
                # 构建源文件路径和目标文件路径
                file_path = os.path.join(root, file)  # 源文件路径
                copy_file_path = os.path.join(copying_folder_path, file)  # 目标文件路径
                # 调用函数处理文件（例如复制文件）
                open_notepad_and_copy(file_path, copy_file_path)

if __name__ == "__main__":
    main()

